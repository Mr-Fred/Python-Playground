#!/usr/bin/env python3

# ticky_check is a script that generates two different reports from an internal ticketing system log file i.e., syslog.log. the logs are generated by a software named 'ticky'. 

# The script is generating two reports: The ranking of errors generated by ticky and The user usage statistics for the service.

# The ranking of errors generated by ticky: A list of all the error messages logged and how many times each error was found, sorted by the most common error to the least common error. This report doesn't take into account the users involved.

# The user usage statistics for the service: A list of all users that have used the system, including how many info messages and how many error messages they've generated. This report is sorted by username.

# this is the final project of the course Using Pythong to interact with the Operating system taught by Google on Coursera.

import re
import csv

def generate_log_report(log_file_path):
  # Initialize empty dictionaries to store error logs and user information
  error = {}
  per_user = {}

  # Regular expression pattern to match error and info messages
  pattern = r"[ticky:]+ ([ERROR|INFO]+) ([\w '\[#\d\]]*)\((.*)\)"

  # Open the log file and read all the lines
  with open(log_file_path, "r") as f:
    errorloglines = f.readlines()

    # Loop through each line and match with the pattern
    for line in errorloglines:
      match = re.search(pattern, line)
      count = match.group(1)
      error_type = match.group(2).strip()
      user = match.group(3)

      # Check if the line is an error message
      if match and count == "ERROR":
        # If the error type is not already in the dictionary, add it with a count of 1
        if error_type not in error:
          error[error_type] = 1
        # If the error type is already in the dictionary, increment the count
        else:
          error[error_type] += 1

      # Check if the user is already in the dictionary, if not initialize a new dictionary for the user
      if user not in per_user:
        per_user[user] = {"INFO": 0, "ERROR": 0}
      # Increment the count for the error or info message for the user
      per_user[user][count] += 1

  # Sort the error logs by the count in descending order
  error = dict(sorted(error.items(), key=lambda x: x[1], reverse=True))
  # Sort the user information by user name in ascending order
  per_user = dict(sorted(per_user.items(), key=lambda x: x[0]))
  # Return both error logs and user information
  return error, per_user

# Call the function and print the per_user dictionary
error, per_user = generate_log_report("data/syslog.log")

# Function to write error dictionary to a CSV file
def error_to_csv(dictionary):
  # Define column names for CSV file
  column_names = ["Error", "Count"]
  # Open CSV file for writing, creating it if it doesn't exist
  with open("data/error_message.csv", "w", newline='') as f:
    # Create a CSV writer object
    writer = csv.DictWriter(f, fieldnames=column_names)
    # Write the header row to the CSV file
    writer.writeheader()
    # Loop over each key-value pair in the dictionary
    for key, value in dictionary.items():
      # Write a row to the CSV file with the key and value
      writer.writerow({column_names[0]: key, column_names[1]: value})
  # Return the filename of the CSV file
  return "data/error_message.csv"

# Function to write per-user dictionary to a CSV file
def per_user_to_csv(dictionary):
  # Define column names for CSV file
  column_names = ["Username", "INFO", "ERROR"]
  # Open CSV file for writing, creating it if it doesn't exist
  with open("data/user_statistics.csv", "w", newline='') as f:
    # Create a CSV writer object
    writer = csv.DictWriter(f, fieldnames=column_names)
    # Write the header row to the CSV file
    writer.writeheader()
    # Loop over each key-value pair in the dictionary
    for key, value in dictionary.items():
      # Write a row to the CSV file with the key and values for "INFO" and "ERROR"
      writer.writerow({column_names[0]: key, column_names[1]: value[column_names[1]], column_names[2]: value[column_names[2]]})
  # Return the filename of the CSV file
  return "data/user_statistics.csv"

# Write the error dictionary to a CSV file
error_to_csv(error)

# Write the per-user dictionary to a CSV file
per_user_to_csv(per_user)
